TODO

Validate number literals to ensure they fit within the valid range; this should probably be in the analyzer
Add binary, hex, and octal literal support

Figure out short-circuiting for boolean operations-- super important!

Exports and imports
    Imports require definition of type signatures
    Have two different import syntaxes; explicit (with type signatures spelled out) and implicit (resolved at compile time)
    Note that only _immutable_ globals (constants) can be imported/exported
    Also have both whole-module imports (import bar) and named imports (from bar import Foo)
    Aliasing should also be possible: (import bar as bar), (from bar import void Foo() as Foobar), (export Foo as Bar)

Pointers/Memory access
    I'd prefer something more structured and less dangerous than pure pointers
    Maybe have syntax for statically "mapping" the memory space with structs and fixed-length arrays
    Mapping syntax would be a good place to set up the Data section stuff, too

Structs
    For locals/globals, allocate suffixed properties (e.g. v: { x, y } becomes "v.x", "v.y") and use scope trickery
    For in-memory use, use static offsets from the struct pointer

Arrays
    Same as structs; always fixed-size, let user code keep a dynamic length separately if desired

LEB is failing on small negative signed numbers due to lack of Long support; HIGH PRIORITY!

If structs are memory-mapped only, we could have byte and short types there!
Given alignment concerns it might still be better to just use whole ints and bit masking, though
Alignment can't be smaller than 4 if there are no datatypes to offset it less than 4
Alternatively, allow smaller sizes but increment the underyling offset by the minimum alignment anyway

We can actually include byte and short types, if we use i32 as backing and truncate when needed 
This would of course be more expensive than just using ints

Structs as memory-mapped constructs, beginning at a certain offset in memory
Include byte/sbyte/short/ushort as valid primitives in structs and arrays
Structs may include any primitives, structs, or fixed-length arrays of primitive or struct values
Warnings if the struct properties are not access-aligned (shorts every 2 bytes, ints every 4 bytes, etc.)
Structs that are aligned on their own may become misaligned when used as part of and array or other struct

Turn main.js into a command-line utility

To make structs work, we need to switch from the hard-coded DataType enum to looking up Type objects in the current scope

For optimization purposes, a switch/branch-table construct would be helpful

We should also create a VSCode language server that provides realtime analysis and validation. Take a look at textdiff-create on NPM for generating diffs to apply formatting
